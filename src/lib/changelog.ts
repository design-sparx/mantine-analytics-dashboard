import fs from 'fs';
import path from 'path';

// Types for changelog data
export interface ChangelogEntry {
  version: string;
  date: string;
  type: 'major' | 'minor' | 'patch';
  description?: string;
  changes: {
    type:
      | 'major'
      | 'minor'
      | 'patch'
      | 'added'
      | 'changed'
      | 'deprecated'
      | 'removed'
      | 'fixed'
      | 'security';
    title?: string;
    items: string[];
  }[];
}

/**
 * Determines the version type based on semver
 */
function getVersionType(version: string): 'major' | 'minor' | 'patch' {
  const cleanVersion = version.replace(/^v/, '');
  const parts = cleanVersion.split('.');
  const major = parseInt(parts[0] || '0');
  const minor = parseInt(parts[1] || '0');
  const patch = parseInt(parts[2] || '0');

  // Check if this is a major version (x.0.0 where x > 0)
  if (major > 0 && minor === 0 && patch === 0) return 'major';
  // Check if this is a minor version (x.y.0 where y > 0)
  if (minor > 0 && patch === 0) return 'minor';
  // Everything else is a patch
  return 'patch';
}

/**
 * Maps changelog section headers to change types
 */
function getChangeType(
  header: string,
):
  | 'major'
  | 'minor'
  | 'patch'
  | 'added'
  | 'changed'
  | 'deprecated'
  | 'removed'
  | 'fixed'
  | 'security' {
  const normalized = header.toLowerCase().trim();

  if (normalized.includes('major changes')) return 'major';
  if (normalized.includes('minor changes')) return 'minor';
  if (normalized.includes('patch changes')) return 'patch';
  if (normalized.includes('added') || normalized.includes('new'))
    return 'added';
  if (
    normalized.includes('changed') ||
    normalized.includes('updated') ||
    normalized.includes('improved')
  )
    return 'changed';
  if (normalized.includes('deprecated')) return 'deprecated';
  if (normalized.includes('removed') || normalized.includes('deleted'))
    return 'removed';
  if (normalized.includes('fixed') || normalized.includes('bug'))
    return 'fixed';
  if (normalized.includes('security')) return 'security';

  return 'changed'; // default fallback
}

/**
 * Extracts date from version header or generates current date
 */
function extractDate(versionLine: string): string {
  // Look for date patterns like "2024-06-25" or other formats
  const dateMatch = versionLine.match(/(\d{4}-\d{2}-\d{2})/);
  if (dateMatch) {
    return dateMatch[1];
  }

  // Fallback to current date
  return new Date().toISOString().split('T')[0];
}

/**
 * Parses the CHANGELOG.md file generated by Changesets
 */
export async function parseChangelog(): Promise<ChangelogEntry[]> {
  try {
    const changelogPath = path.join(process.cwd(), 'CHANGELOG.md');

    if (!fs.existsSync(changelogPath)) {
      throw new Error('CHANGELOG.md not found in project root');
    }

    const content = fs.readFileSync(changelogPath, 'utf-8');
    const lines = content.split('\n');

    const entries: ChangelogEntry[] = [];
    let currentEntry: Partial<ChangelogEntry> | null = null;
    let currentChangeType: string | null = null;
    let currentItems: string[] = [];
    let collectingDescription = false;
    let descriptionLines: string[] = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();

      // Skip empty lines, main title, and package name
      if (
        !trimmedLine ||
        trimmedLine === '# Changelog' ||
        trimmedLine === '# analytics-dashboard' ||
        trimmedLine.startsWith('All notable changes')
      ) {
        continue;
      }

      // Version header (## 3.0.0)
      if (
        trimmedLine.startsWith('## ') &&
        /## \d+\.\d+\.\d+/.test(trimmedLine)
      ) {
        // Save previous entry if exists
        if (currentEntry && currentEntry.version) {
          // Save any remaining change type
          if (currentChangeType && currentItems.length > 0) {
            currentEntry.changes = currentEntry.changes || [];
            currentEntry.changes.push({
              type: getChangeType(currentChangeType),
              title: currentChangeType,
              items: [...currentItems],
            });
          }

          // Add collected description
          if (descriptionLines.length > 0) {
            currentEntry.description = descriptionLines.join(' ').trim();
          }

          entries.push(currentEntry as ChangelogEntry);
        }

        // Start new entry
        const version = trimmedLine.replace('## ', '').trim();
        currentEntry = {
          version,
          date: extractDate(trimmedLine),
          type: getVersionType(version),
          changes: [],
        };
        currentChangeType = null;
        currentItems = [];
        collectingDescription = false;
        descriptionLines = [];
      }

      // Change type header (### Major Changes, ### Patch Changes, etc.)
      else if (trimmedLine.startsWith('### ') && currentEntry) {
        // Save previous change type if exists
        if (currentChangeType && currentItems.length > 0) {
          currentEntry.changes = currentEntry.changes || [];
          currentEntry.changes.push({
            type: getChangeType(currentChangeType),
            title: currentChangeType,
            items: [...currentItems],
          });
        }

        currentChangeType = trimmedLine.replace('### ', '');
        currentItems = [];
        collectingDescription = false;
      }

      // List item with hash (- f171570: description)
      else if (trimmedLine.startsWith('- ') && currentEntry) {
        const item = trimmedLine.replace('- ', '').trim();
        if (item) {
          // Extract the actual change description (remove hash if present)
          const cleanItem = item.replace(/^[a-f0-9]+:\s*/, '').trim();
          if (cleanItem) {
            currentItems.push(cleanItem);
          }
        }
        collectingDescription = false;
      }

      // Multi-line description (usually after a hash line)
      else if (
        currentEntry &&
        currentChangeType &&
        trimmedLine &&
        !trimmedLine.startsWith('#')
      ) {
        // If we just started a new item and this looks like a description
        if (
          currentItems.length > 0 &&
          (trimmedLine.startsWith('This release') ||
            trimmedLine.startsWith('###') ||
            trimmedLine.startsWith('- ') ||
            trimmedLine.includes("What's New") ||
            trimmedLine.includes('âœ¨') ||
            trimmedLine.includes('ðŸš€'))
        ) {
          collectingDescription = true;
        }

        if (collectingDescription) {
          descriptionLines.push(trimmedLine);
        }
      }
    }

    // Don't forget the last entry
    if (currentEntry && currentEntry.version) {
      if (currentChangeType && currentItems.length > 0) {
        currentEntry.changes = currentEntry.changes || [];
        currentEntry.changes.push({
          type: getChangeType(currentChangeType),
          title: currentChangeType,
          items: [...currentItems],
        });
      }

      if (descriptionLines.length > 0) {
        currentEntry.description = descriptionLines.join(' ').trim();
      }

      entries.push(currentEntry as ChangelogEntry);
    }

    return entries;
  } catch (error) {
    console.error('Error parsing changelog:', error);
    throw error;
  }
}

/**
 * Gets changelog data for API routes or static generation
 */
export async function getChangelogData(): Promise<{
  changelog?: ChangelogEntry[];
  error?: string;
}> {
  try {
    const changelog = await parseChangelog();
    return { changelog };
  } catch (error) {
    console.error('Failed to get changelog data:', error);
    return {
      error:
        error instanceof Error ? error.message : 'Failed to load changelog',
    };
  }
}
